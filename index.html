<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Raspberry Pi</h2>
					<p></p>
					<h3>Lerne die Programmierung eines Mikrocomputers kennen</h3>
					<p>
					<small>Sven Krauß</small>
					</p>
				</section>
				<section>
					<h2>Termine</h2>
					<ul>
						<li>KW7 > 12.02.2026</li>
						<li>KW9 > 26.02.2026</li>
						<li>KW10 > 05.03.2026</li>
						<li>KW11 > 12.03.2026</li>
						<li>KW12 > 19.03.2026</li>
						<li>KW13 > 26.03.2026</li>
					</ul>
					<small>Uhrzeit: 16 - 18 Uhr</small>
					<!--img src="logo.svg" width="200"-->
				</section>
				<section>
					<h3>Themenübersicht</h3>
					<ol>
						<li>Was ist ein Raspberry Pi?<br><small>Einführung und den Raspberry Einrichten</small></li>
						<li>Einführung in Python<br><small>print("Hallo Welt")</small></li>
						<li>Arbeiten mit den GPIOs<br><small>LEDs und Taster</small></li>
						<li>Sensoren einlesen</li>
						<li>Weitere Themen</li>
						<ul>
							<small>
								<li>Raspberry Pi im Netzwerk</li>
								<li>Sonic Pi</li>
								<li>EMails automatisiert versenden</li>
								<li>Eure Vorschläge</li>
							</small>
						</ul>
					</ol>
				</section>
				<section>
					<section>
						<h2>Was ist der Raspberry Pi</h2>
						<ul>
							<li>Komponenten des Pi</li>
							<li>Anschlüsse</li>
							<li>Umgang mit dem Pi - Was ist ESD?</li>
							<li>Betriebssystem</li>
						</ul>
					</section>
					<section>
						<h3>Hardware</h3>
						<img src="images/Hardware.png"/>
					</section>
					<section>
						<h3>Einige Anwendungen</h3>
						<ul>
							<li>Desktop-Computer</li>
							<li>Internetradio</li>
							<li>Überwachungskamera / Webcam</li>
							<li>Robotersteuerung</li>
							<li>IoT / Hausautomation</li>
							<li>Web-Server</li>
							<li>Datenlogger</li>
							<li>Kiosk-Modus</li>
							<li>Retro-Spiele</li>
							<li>...</li>
						</ul>					
					</section>
					<section>
						<h3>Installation</h3>
						<img src="images/Installer.png"/>
					</section>

					<section>
						<h3>Aufbau und Start</h3>
						<blockquote>
							Aufgabe: Systemupdate
						</blockquote>
					</section>

					<section>
						<h2>Unterschiede in den Programmiersprachen</h2>
						<p>Einteilung in zwei Gruppen!</p>
						<ul>
							<li>Compilierte Programmiersprachen</li>
							<li>Interpretierte Programmiersprachen</li>
						</ul>
					</section>

					<section>
						<h3>Compilierte Programmiersprachen</h3>
						<img src="images/compiler.png"/>
					</section>

					<section>
						<h3>Interpretierte Programmiersprachen</h3>
						<img src="images/interpreter.png"/>
					</section>
				</section>

				<section>
					<section>
						<h2>Einführung in Python</h2>
						<pre><code data-trim data-line-numbers>
							print("Hallo Welt")
							ida = 5
							ida
							paul = 42
							paul						
							print("Ida ist", ida)
							print("Paul ist", paul)
							print("Zusammen sind sie", (paul + ida))
							ida=paul
							print("Zusammen sind sie", (paul + ida))
						</code></pre>
					</section>

					<section>
						<h3>Entwicklungsumgebung</h3>
						<p>Demo</p>
					</section>

					<section>
						<h3>Quadrierer</h3>
						<pre><code data-trim data-line-numbers>
							zahl = input("Gib eine Zahl ein: ")
							quadrat = zahl*zahl
							print("Das Quadrat ist:", quadrat)
						</code></pre>
					</section>

					<section>
						<h3>Datentypen</h3>
						<p>(Im Interpreter)</p>
						<pre><code data-trim data-line-numbers>
							var = -5
							type(var)

							var = 5.0
							type(var)

							var = "Hallo Welt"
							type(var)

							var = "55"
							type(var)

							var = int(var)
							type(var)
						</code></pre>
					</section>

					<section>
						<h3>Verzweigungen</h3>
							<pre><code class="py" data-trim data-line-numbers>
								if [Bedingung]:
									[Anweisung]
									...
								elif [Bedingung]:
									[Anweisung]
									...
								else:
									[Anweisung]
									...
							</code></pre>
							<p>
								Bedingungen können sein:
							</p>
							<small><ul>
								<li>Kleiner: a &lt; b</li>
								<li>Größer: a &gt; b</li>
								<li>Kleiner gleich: a &lt;= b</li>
								<li>Größer gleich: a &gt;= b</li>
								<li>Gleich a == b</li>
							</ul></small>
					</section>

					<section>
						<h3>Syntax</h3>
							<pre><code class="py" data-trim data-line-numbers>
								if [Bedingung]:
									[Anweisung1] #Innerhalb der Bedingung
									[Anweisung2] #Innerhalb der Bedingung
									...
								[Anweisung3] #Gehört NICHT zur Bedingung
							</code></pre>
							<small>
							<p>
								Ein zusammenhängender Code-Block wird anhand der Einrückung identifiziert.
							</p>
							</small>
					</section>

					<section>
						<h3>Verzweigungen - Beispiel</h3>
							<pre><code class="py" data-trim data-line-numbers>
								alter = input("Wie alt bist du? ")
								alter = int(alter)
								if alter < 10:
									print("Kind")
								elif alter < 18:
									print("Jugendlich")
								else:
									print("Erwachsen")
							</code></pre>
							<small>
								<p>Aufgabe:</p>
								<p>Erweitere das Beispiel so, dass auch "Rentner" ab eine Alter von 65 ausgegeben wird.</p>
							</small>
					</section>

					<section>
						<h3>While-Schleifen</h3>
						<pre><code class="py" data-trim data-line-numbers>
							while Bedingung:
								Anweisung
								...
								break
						</code></pre>
					</section>
					<section>
						<p>Zahlenraten</p>
						<pre><code class="py" data-trim data-line-numbers>
							from random import randint

							print("Rate eine Zahl zwischen 1 und 100")
							zufallszahl = randint(1,100)
							zahl = int(input("Dein Vorschlag: "))

							while zahl != zufallszahl:
								if zahl < zufallszahl:
									print("Zu klein")
								else:
									print("Zu groß")
								zahl = int(input("Dein Vorschlag: "))

							print("Richtig!")
						</code></pre>
						<small>
							<p>Aufgabe für die Profis:</p>
							<p>Wie kann das Programm geändert werden, so dass die Abfrage int(input(...)) nur 
								einmal programmiert werden muss</p>
						</small>
					</section>

					<section>
						<h3>For-Schleifen</h3>
						<pre><code class="py" data-trim data-line-numbers>
							for X in I:
								Anweisung
								...
								break
						</code></pre>
						<p>Beispiel Fakultät</p>
						<pre><code class="py" data-trim data-line-numbers>
							f = 1
							for i in range(1,10):
								f = f * i
							
							print("Fakultät von:", 9, "ist", f)
						</code></pre>
					</section>

					<section>
						<h3>Funktionen</h3>
						<pre><code class="py" data-trim data-line-numbers>
							f = 1
							for i in range(1,10):
								f = f * i
							print("Fakultät von:", 9, "ist", f)

							f = 1
							for i in range(1,18):
								f = f * i
							print("Fakultät von:", 17, "ist", f)
						</code></pre>
					</section>

					<section>
						<h3>Funktionen (2)</h3>
						<pre><code class="py" data-trim data-line-numbers>
							def name(parameter, ...):
								Anweisung
								...
								return Wert (optional)
						</code></pre>
						<p>Beispiel Fakultät</p>
						<pre><code class="py" data-trim data-line-numbers>
							def faku(inp):
								f = 1
								for i in range(1, inp + 1):
									f = f * i
								print("Fakultät von:", inp, "ist", f)	
							
							faku(9)
							faku(17)
						</code></pre>
					</section>

					<section>
						<h3>Funktionen (3)</h3>
						<p>Rückgabewerte</p>
						<pre><code class="py" data-trim data-line-numbers>
							def faku(inp):
								f = 1
								for i in range(1, inp + 1):
									f = f * i
								return f
							
							x = faku(9)
							print("Fakultät von:", 9, "ist", x)
							print("Fakultät von:", 13, "ist", faku(13))
						</code></pre>
						<small>
							<p>Aufgabe:</p>
							<p>Schreibe eine Funktion, dass die Fibonacci-Folge erzeugt und anzeigt. 
								Die Länge der Folge soll mit einem Funktions-Parameter geändert werden können.</p>
						</small>
					</section>

					<section>
						<h3>Bibliotheken einbinden</h3>
						<ul>
							<li>Die meisten Probleme in der Softwareentwicklung wurden schon von 
								anderen bearbeitet.</li>
							<li>Teile der Problemlösung können in Bibliotheken bereitgestellt werden.</li>
							<li>Das Rad muss nicht neu erfunden werden.</li>
						</ul>
						<pre><code class="py" data-trim data-line-numbers>
							import random
							import math

							zufallszahl = random.randint(1,100)
							s = math.sin(0.5)
						</code></pre>
						<p><a href="https://docs.python.org/3/library/index.html">Python Standard Bibliothek</a></p>
						<p><a href="https://pypi.org/">Python Package Index</a></p>
					</section>
				</section>

				<section>
					<!-- https://pimylifeup.com/raspberry-pi-gpio/ -->
					<section>
						<h2>General Purpose Input/Output</h2>
						<img src="images/Display.png"/>
					</section>

					<section>
						<h3>GPIO Pins (Layout)</h3>
						<img src="images/Pins.png" height="500"/>
						<img src="images/GPIOs.png" height="500"/>					
					</section>

					<section>
						<h3>GPIO mit Python ansteuern</h3>
						<ul>
							<li>Es gibt zwei verschiedene Modi für die Identifizierung
								<ol>
									<li class="fragment highlight-current-green">Die BOARD-Methode verwendet die Nummern 1 bis 40 entsprechend dem Layout.</li>
									<li class="fragment highlight-current-green">Die BCM-Methode bezeichnet die Pins entsprechend ihres Interface-Kanals (channel).</li>
								</ol>
							</li>
							<li class="fragment highlight-current-green">Einige GPIO-Anschlüsse können mehrere Funktionen übernehmen (SPI, I2C, USB...)</li>
							<li class="fragment highlight-current-green">Achtung: Ein GPIO-Ausgang darf mit maximale 16mA belastet werden.</li>
							<li class="fragment highlight-current-green">Alles GPIOs funktionieren mit 3.3V</li>
						</ul>
					</section>

					<section>
						<h3>GPIO mit Python ansteuern 2</h3>
						<ul>
							<li>Die 'RPi'-Bibliothek erlaubt den Ansteuerung der GPIO-Anschlüsse</li>
						</ul>
						<pre><code class="py" data-trim data-line-numbers>
							import RPi.GPIO as GPIO

							GPIO.setmode(GPIO.BCM)
						</code></pre>
					</section>

					<section>
						<h3>Aufbau mit Breadboard</h3>
						<img src="images/Verdrahtung1.png" height="500"/>
					</section>

					<section>
						<h3>Aufbau mit Breadboard</h3>
						<img src="images/Verdrahtung2.png" height="500"/>
					</section>

					<section>
						<h3>Aufbau mit Breadboard</h3>
						<img src="images/Verdrahtung3.png" height="500"/>
					</section>
				</section>

				<section>
					<section>
						<h3>Blinkende Leuchtdiode</h3>					
						<ul>
							<li>LEDs können nur mit einem Vorwiderstand an den GPIOs angeschlossen werden. 
							In dem Fall 150 Ohm.</li>
							<li>Die Polarität muss beachtet werden. Der lange Anschluss	kennzeichnet die 
								Anode und muss mit der positiven Seite der Spannungsversorgung verbunden 
								werden.	Der kurze Anschluss ist die Kathode und gehört an die negative 
								Seite (hier Ground GND).</li>
						</ul>
					</section>
					<section>
						<h3>Blinkende Leuchtdiode</h3>
						<img src="images/LED1.png" height="500"/>
					</section>
					<section>
						<h3>Blinkende Leuchtdiode</h3>
						<pre><code class="py" data-trim data-line-numbers>
							import time
							import RPi.GPIO as GPIO
							
							led_pin = 18
							
							GPIO.setmode(GPIO.BCM)
							GPIO.setup(led_pin, GPIO.OUT)
							
							try:
								while True:
									GPIO.output(led_pin, GPIO.HIGH)
									time.sleep(0.5)
									GPIO.output(led_pin, GPIO.LOW)
									time.sleep(0.5)
							except KeyboardInterrupt:
								pass
							
							GPIO.cleanup()
						</code></pre>
					</section>
				</section>

				<!-- https://indibit.de/raspberry-pi-gpio-ausgaenge-schalten-eingaenge-lesen/ -->
				<section>
					<section>
						<h2>Taster abfragen</h2>
						<ul>
							<li>Kann verwendet werden um den Zustand eines elektrischen Kontakts zu erfassen</li>
							<li>z.B. Lichtschranken, Türkontakte, Taster, etc...</li>
							<li>Pull-Up oder Pull-Down beachten <a href="https://www.elektronik-kompendium.de/sites/raspberry-pi/2006051.htm">(Klick)</a></li>						
							<li>Die Pull-Up / Pull-Down Widersände sind in der CPU bereits eingebaut und können über die Bibliothek
								aktiviert werden.
							</li>
						</ul>
					</section>

					<section>
						<h3>Taster abfragen</h3>
						<img src="images/Pullup.png" height="500"/>
					</section>

					<section>
						<h3>Taster abfragen</h3>
						<img src="images/Taster1.jpeg" height="500"/>
					</section>

					<section>
						<h3>Taster abfragen</h3>
						<pre><code class="py" data-trim data-line-numbers>
							import time
							import RPi.GPIO as GPIO
							
							tast_pin = 17
							
							GPIO.setmode(GPIO.BCM)
							GPIO.setup(tast_pin, GPIO.IN, pull_up_down = GPIO.PUD_UP)
							try:
								while True:
									time.sleep(0.5)
									if GPIO.input(tast_pin) == GPIO.HIGH:
										print("Taster (nicht) gedrückt")
									else:
										print("Taster (nicht) gedrückt")
								
							except KeyboardInterrupt:
								pass
							
							GPIO.cleanup()
						</code></pre>
					</section>

					<section>
						<h3>Taster abfragen</h3>
						<p>Aufgabe: Ändere das Programm so ab, dass nur die Ereignisse "Taste gedrückt" 
							und "Taste losgelassen" ausgegeben werden.
						</p>
					</section>

					<section>
						<h3>Taster abfragen</h3>
						<pre><code class="py" data-trim data-line-numbers>
							import time
							import RPi.GPIO as GPIO

							tast_pin = 17

							GPIO.setmode(GPIO.BCM)
							GPIO.setup(tast_pin, GPIO.IN, pull_up_down = GPIO.PUD_UP)
							
							# Callback-Funktion
							def ereignis(channel):
								print("Taster gedrückt")
																					
							GPIO.add_event_detect(tast_pin, GPIO.FALLING, 
												  callback = ereignis, bouncetime = 200)
							
							try:
								while True:
									time.sleep(0.5)
							
							except KeyboardInterrupt:
								pass
							
							GPIO.cleanup()							
						</code></pre>
					</section>
					<section>
						<h3>Felhermeldung</h3>
						<p>Neuere Raspberry Pi OS verwenden eine andere Schnittstelle für die event_detect Funktion.
						 Hier hilft es eine andere Bibliothek zu verwenden.</p>
						<pre><code class="bash">
							sudo apt install python3-rpi-lgpio
						</code></pre></pre>
					</section>
					<section>
						<h3>Taster und LED kombinieren</h3>
						<p>Aufgabe: Ändere das Programm so ab, dass die LED genau 3x blinkt wenn der Taster gedrückt wird.
						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Raspberry Pi im Netzwerk</h2>
						<img src="images/network1.jpeg" height="500"/>
					</section>
					<section>
						<h3>Netzwerkstruktur</h3>
						<img src="images/netzwerk2.jpg" height="200"/>
						<ul>
							<li>Ende-zu-Ende-Kommunikation</li>
							<li>Paketorientiert</li>
							<li>Datenkanal zwischen zwei Teilnehmern</li>
						</ul>
					</section>

					<section>
						<h3>Netzwerkstruktur</h3>
						<img src="images/netzwerk3.jpg" height="600"/>
					</section>

					<section>
						<h3>Client-Server-Architektur</h3>
						<img src="images/netzwerk4.jpg" height="300"/>
					</section>

					<section>
						<h3>Was sind IP Adressen</h3>
						<ul>
							<li>Eindeutige Adresse in einem Netzwerk</li>
							<li>Zwei Arten von IP-Adressen: IPv4 und IPv6</li>
							<li>IPv4: X.X.X.X z.B. 10.2.22.55</li>
							<li>Man unterscheidet zwischen privaten und öffentlichen Adressen</li>
						</ul>
						<pre><code class="bash">
							ip a
						</code></pre>
					</section>

					<section>
						<h3>Was sind Ports?</h3>
						<ul>
							<li>Ein Port ist ein "Teil" einer Adresse und umfasst den Wertebereich 0 bis 65535</li>
							<li>Zuordnung von <b>Diensten</b> zu Port-Nummern.</li>
							<li>Client und Server "binden" sich an jeweils einen Port, wenn eine Verbindung aufgebaut wird.</li>
							<li>Ports 0 bis 1023: System Ports</li>
							<li>Ports 1024 bis 49151: Registered Ports</li>
							<li>Ports 49152 bis 65535: Dynamic Ports</li>
						</ul>
					</section>

					<section>
						<h3>Netcat</h3>
						<p>Server-Seite</p>
						<pre><code class="bash">
							netcat -l -p 50000
						</code></pre></pre>
						<p>Client-Seite</p>
						<pre><code class="bash">
							netcat X.X.X.X 50000
						</code></pre>
					</section>

					<section>
						<h3>Frage-Antwort-Spiel - Server</h3>
						<pre><code class="py" data-trim data-line-numbers>						
							import sys
							import socket

							sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
							sock.bind(("", 51000))
							sock.listen(1)

							while True:
								print("Warte auf deinen Spieler ")
								spieler, addr = sock.accept()
								print("Spieler hat sich verbunden. Seine Adresse ist ", addr)
								try:
									while True:
										print("Warte auf Frage...")
										frage = spieler.recv(256)
										if frage:
											print("Emfangen: " + frage.decode())
											antwort = input("Tippe die Antwort ein und dann ENTER: ")
											spieler.sendall(antwort.encode())
										else:
											print("EOF")
											break
								finally:
									spieler.close()
						</code></pre>
					</section>

					<section>
						<h3>Frage-Antwort-Spiel - Client</h3>
						<pre><code class="py" data-trim data-line-numbers>						
							import sys
							import socket
							import time
							
							spieler = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
							print("Verbinde zum Spieler ...")
							spieler.connect(("10.2.15.154", 51000))
							print("Verbunden")
							
							try:
								while True:
									frage = input("Tippe deine Frage ein und dann ENTER: ")
									spieler.sendall(frage.encode())
									print("Warte auf die Antwort")
									antwort = spieler.recv(256)
									print("Antwort: " + antwort.decode())
							finally:
								print("Cleanup")
								sock.close()
						</code></pre>
					</section>
					<section>
						<h2>Aufgabe</h2>
						<p>(1) Schließe einen Taster am Rasperry PI an. Bei Betätigung des
							Tasters soll eine Nachricht an den Client gesendet werden.</p>
						<p>(2) Schließe eine LED am Rasperry PI an. Bei Empfang der Nachricht "an"
							soll die LED angehen und bei Emfang der Nachricht "aus" entsprechend aus.</p>
						</section>
				</section>

				<section>
					<section>
						<h2>EMail und Co</h2>
						<h3>Themen</h3>
						<ul>
							<li>Aufbau von E-Mails</li>
							<li>MUA, MSA, MTA, MDA und MRA</li>
							<li>SMTP Protokoll</li>
							<li>EMail Client einrichten</li>
							<li>Python MUA</li>
						</ul>
					</section>
					<section>
						<h2>Aufbau einer E-Mail</h2>
						<pre><code class="txt" data-trim data-line-numbers><script type="text/template">
							Message-ID: <68ce9779939fa97b7f1c4e1dfccd06017f4e3b51.camel@web.de>
							Subject: Testmail
							From: Sven Krauss <sven.krauss@web.de>
							To: sven.krauss@posteo.de
							Date: Tue, 10 Dec 2024 14:47:33 +0100
							Content-Type: text/plain
							Content-Transfer-Encoding: 7bit
								
							Einfacher Test
						</script></code></pre>
					</section>
					<section>
						<h3>Ganz viele MMMMM</h3>
						<img src="images/mail1.jpg" height="400"/>
						<small><p>Quelle: <a href="https://oxilor.com/blog/how-does-email-work">How does email work</a></p></small>
					</section>
					<section>
						<h3>Ganz viele MMMMM</h3>
						<table>
							<tr><th>Abk.</th><th>Beschreibung</th></tr>
							<tr><td>MUA</td><td>Mail User Agent. </td></tr>
							<tr><td>MSA</td><td>Mail Submission Agent. </td></tr>
							<tr><td>MTA</td><td>Mail Transfer Agent. </td></tr>
							<tr><td>MDA</td><td>Mail Delivery Agent. </td></tr>
							<tr><td>MRA</td><td>Mail Retrieval Agent. </td></tr>
						</table>
					</section>
					<section>
						<h3>EMail Client einrichten</h3>
						<pre><code class="bash">
							sudo apt update
							sudo apt install geary
						</code></pre>
						<p>Starte Geary und richte dein Account ein.</p>
					</section>

					<section>
						<h3>Nachricht erstellen (sendmail.py)</h3>
						<pre><code class="py" data-trim data-line-numbers>
							from email.message import EmailMessage

							def create_msg(from_addr, to_addr, inhalt):
								msg = EmailMessage()
								msg.set_content(inhalt)
							
								msg['Subject'] = "Mein Betreff"
								msg['From'] = from_addr
								msg['To'] = to_addr
								return msg
						</code></pre>
					</section>

					<section>
						<h3>Versenden mit SMTP (sendmail.py)</h3>
						<pre><code class="py" data-trim data-line-numbers>
							import smtplib, ssl
							
							def send_msg(from_addr, msg):
							
								server = "w00962be.kasserver.com"
								port = 465
							
								# Login Passwort abfragen
								prompt = "Login für {}: ".format(from_addr)
								passwort = input(prompt)
							
								# Sichere Verbindung aufbauen, einloggen und senden
								ssl_ctx = ssl.create_default_context()
								s = smtplib.SMTP_SSL(server, port, context=ssl_ctx)
								s.login(from_addr, passwort)
								s.send_message(msg)
								s.quit()
						</code></pre>
					</section>

					<section>
						<h3>Eigene Bibliothek verwenden</h3>
						<pre><code class="py" data-trim data-line-numbers>
							import sendmail

							inhalt = "Langer langer text"
							sender = "tn1@phaenovum.de"
							empfänger = "tn2@phaenovum.de"
							
							nachricht = sendmail.create_msg(sender, empfänger, inhalt)
							sendmail.send_msg(sender, nachricht)
						</code></pre>
					</section>

					<section>
						<h3>Aufgabe</h3>
						<p>(1) Erstelle ein Programm, mit einem Tastendruck eine E-Mail versendet.</p>
						<p>(2) Binde den Abstandssensor ein und schicke eine Mail mit dem gemessenen Wert.</p>
					</section>

				</section>

				<section>
					<section>
						<h2>Sonic Pi</h2>
						<p>
							Installation im Terminal:
							<pre><code class="bash">
								sudo apt install sonic-pi
							</code></pre>
						</p>
						
						<p><a href="https://sonic-pi.net/tutorial.html">Anleitung</a></p>
						<small>
						<p><a href="https://youtu.be/LaKT3pli5EQ">Live Coding (Youtube)</a></p>
						<p><a href="https://youtu.be/rnCE7hxNGXw">Live Coding von Sam Aaron (Youtube)</a></p>
						</small>
					</section>
				</section>

				<section>
					<section>
						<h2>Abschlussprojekt</h2>
						<p>
							Ziel: Wir bauen ein Sensor, der in einem Winkel von 180 Grad
							den kleinsten Abstand zum Sensor bestimmt.
						</p>
						<p>Dazu befestigen wir auf einem Servomotor ein Ultraschallsensor. Damit kann der 
							Ultraschallsensor um 180 Grad gedreht werden.
						</p>
						<p>
							Es soll ein Programm geschrieben werden, dass die Umgebung abscannt und im Anschluss 
							den Sensor auf das Ziel richtet.
						</p>
					</section>
					<section>
						<h2>Aufgaben / Funktionen</h2>
						<ol>
							<li>Ansteuerung Servomotor</li>
							<li>Ansteuerung Ultraschallsensor</li>
							<li>Algorithmus zum scannen und positionieren</li>
						</ol>
						<p>Bildet drei Gruppen, die jeweils ein Thema bearbeiten. Am Ende werden wir 
							alles auf einem Raspberry Pi zusammenfügen.</p>
					</section>
					<section>
						<h2>Grobstruktur / Zusammenarbeit</h2>
						<pre><code class="py" data-trim data-line-numbers>						
							def setze_position(winkel):
							    print("Neuer Winkel: ", winkel)

							def messe_abstand():
								return 0.0

							def ermittle_winkel():
								return -1

							def programm():
								winkel = ermittle_winkel()
								if winkel >= 0:
									print("Kleinster Abstand gefunden bei:", winkel)
									setze_position(winkel)        
								else:
									print("Nichts gefunden")

							programm()
						</code></pre>
					</section>
					<section>
						<h2>(Modellbau-)Servos ansteuern</h2>
					</section>
					<section>						
						<p><img src="images/servo1.jpg" height="500"/></p>
					</section>
					<section>
						<p><img src="images/servo2.jpg" height="500"/></p>
					</section>
					<section>
						<p><img src="images/servo3.png" height="500"/></p>
						<p><a href="https://dasraspberrypi.de/servo-himbeer-pi/">Anleitung Ansteuerung</a></p>
					</section>
					<section>
						<h2>Ultraschallsensor HC-SR04</h2>						
						<p><a href="https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf">Funktionsweise</a></p>
						<p><a href="https://tutorials-raspberrypi.de/entfernung-messen-mit-ultraschallsensor-hc-sr04/">Anleitung</a></p>
					</section>
				</section>				
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				showHiddenSlides: true,
				slideNumber: 'c/t',
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
